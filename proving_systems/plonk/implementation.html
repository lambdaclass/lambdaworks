<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementation - docs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Proving Systems</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../proving_systems/starks/starks.html"><strong aria-hidden="true">2.1.</strong> STARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../proving_systems/starks/recap.html"><strong aria-hidden="true">2.1.1.</strong> Recap</a></li><li class="chapter-item expanded "><a href="../../proving_systems/starks/implementation.html"><strong aria-hidden="true">2.1.2.</strong> Implementation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../proving_systems/starks/api.html"><strong aria-hidden="true">2.1.2.1.</strong> High Level API</a></li><li class="chapter-item expanded "><a href="../../proving_systems/starks/under_the_hood.html"><strong aria-hidden="true">2.1.2.2.</strong> Under the hood</a></li></ol></li><li class="chapter-item expanded "><a href="../../proving_systems/starks/faq.html"><strong aria-hidden="true">2.1.3.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="../../proving_systems/plonk/plonk.html"><strong aria-hidden="true">2.2.</strong> PLONK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../proving_systems/plonk/recap.html"><strong aria-hidden="true">2.2.1.</strong> Recap</a></li><li class="chapter-item expanded "><a href="../../proving_systems/plonk/protocol.html"><strong aria-hidden="true">2.2.2.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="../../proving_systems/plonk/implementation.html" class="active"><strong aria-hidden="true">2.2.3.</strong> Implementation</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> FFT Library</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fft/benchmarks.html"><strong aria-hidden="true">3.1.</strong> Benchmarks</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">docs</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>In this section we discuss the implementation details of the PLONK algorithm. We use the notation and terminology of the <a href="./protocol.html">protocol</a> and <a href="./recap.html">recap</a> sections. </p>
<p>At the moment our API supports the backend of PLONK. That is, all the setup, prove and verify algorithms. We temporarily rely on external sources for the definition of a circuit and the creation of the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrices, as well as the execution of it to obtain the trace matrix <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>. We mainly use gnark temporarily for that purpose.</p>
<p>So to generate proofs and validate them, we need to feed the algorithms with precomputed values of the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrices, and the primitive root of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>.</p>
<p>Let us see our API on a test circuit that provides all these values. The program in this case is the one that takes an input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, a private input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> and computes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>. As in the toy example of the recap, the output of the program is added to the public inputs and the circuit actually asserts that the output is the claimed value. So more precisely, the prover will generate a proof for the statement <code>ASSERT(x*e+5==y)</code>, where both <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> are public inputs.</p>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>Here is the happy path.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is the common preprocessed input for
// the test circuit ( ASSERT(x * e + 5 == y) )
let common_preprocessed_input = test_common_preprocessed_input_2();

// Input
let x = FieldElement::from(2_u64);

// Private input
let e = FieldElement::from(3_u64);

let y, witness = test_witness_2(x, e);

let srs = test_srs(common_preprocessed_input.n);
let kzg = KZG::new(srs);

let verifying_key = setup(&amp;common_preprocessed_input, &amp;kzg);

let random_generator = TestRandomFieldGenerator {};
let prover = Prover::new(kzg.clone(), random_generator);

let public_input = vec![x.clone(), y];

let proof = prover.prove(
    &amp;witness,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key,
);

let verifier = Verifier::new(kzg);
assert!(verifier.verify(
    &amp;proof,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key
));
<span class="boring">}
</span></code></pre></pre>
<p>Let's brake it down. The helper function <code>test_common_preprocessed_input_2()</code> returns an instance of the following struct for the particular test circuit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CommonPreprocessedInput&lt;F: IsField&gt; {
    pub n: usize,
    pub domain: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub omega: FieldElement&lt;F&gt;,
    pub k1: FieldElement&lt;F&gt;,

    pub ql: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qr: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qo: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qm: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qc: Polynomial&lt;FieldElement&lt;F&gt;&gt;,

    pub s1: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub s2: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub s3: Polynomial&lt;FieldElement&lt;F&gt;&gt;,

    pub s1_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub s2_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub s3_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Apart from the eight polynomials in the canonical basis, we store also here the number of constraints <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, the domain <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, the primitive <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-th of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> and the element <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. The element <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> will be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>. For convenience, we also store the polynomials <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">σi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in Lagrange form.</p>
<p>The following lines define the particular values of the program input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and the private input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Input
let x = FieldElement::from(2_u64);

// Private input
let e = FieldElement::from(3_u64);
let y, witness = test_witness_2(x, e);
<span class="boring">}
</span></code></pre></pre>
<p>The function <code>test_witness_2(x, e)</code> returns an instance of the following struct, that holds the polynomials that interpolate the columns <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> of the trace matrix <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Witness&lt;F: IsField&gt; {
    pub a: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub b: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub c: Vec&lt;FieldElement&lt;F&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next the commitment scheme KZG (Kate-Zaverucha-Goldberg) is instantiated.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let srs = test_srs(common_preprocessed_input.n);
let kzg = KZG::new(srs);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>setup</code> function performs the setup phase. It only needs the common preprocessed input and the commitment scheme.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verifying_key = setup(&amp;common_preprocessed_input, &amp;kzg);
<span class="boring">}
</span></code></pre></pre>
<p>It outputs an instance of the struct <code>VerificationKey</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VerificationKey&lt;G1Point&gt; {
    pub qm_1: G1Point,
    pub ql_1: G1Point,
    pub qr_1: G1Point,
    pub qo_1: G1Point,
    pub qc_1: G1Point,

    pub s1_1: G1Point,
    pub s2_1: G1Point,
    pub s3_1: G1Point,
}
<span class="boring">}
</span></code></pre></pre>
<p>It stores the commitments of the eight polynomials of the common preprocessed input. The suffix <code>_1</code> means it is a commitment. It comes from the notation <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is a polynomial.</p>
<p>Then a prover is instantiated</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let random_generator = TestRandomFieldGenerator {};
let prover = Prover::new(kzg.clone(), random_generator);
<span class="boring">}
</span></code></pre></pre>
<p>The prover is an instance of the struct <code>Prover</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F, CS, R&gt;
where
  F:  IsField,
  CS: IsCommitmentScheme&lt;F&gt;,
  R:  IsRandomFieldElementGenerator&lt;F&gt;
  {
    commitment_scheme: CS,
    random_generator: R,
    phantom: PhantomData&lt;F&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>It stores an instance of a commitment scheme and a random field element generator needed for blinding polynomials.</p>
<p>Then the public input is defined. As we mentioned in the recap, the public input contains the output of the program.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let public_input = vec![x.clone(), y];
<span class="boring">}
</span></code></pre></pre>
<p>We then generate a proof using the prover's method <code>prove</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let proof = prover.prove(
    &amp;witness,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key,
);
<span class="boring">}
</span></code></pre></pre>
<p>The output is an instance of the struct <code>Proof</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Proof&lt;F: IsField, CS: IsCommitmentScheme&lt;F&gt;&gt; {
    // Round 1.
    /// Commitment to the wire polynomial `a(x)`
    pub a_1: CS::Commitment,
    /// Commitment to the wire polynomial `b(x)`
    pub b_1: CS::Commitment,
    /// Commitment to the wire polynomial `c(x)`
    pub c_1: CS::Commitment,

    // Round 2.
    /// Commitment to the copy constraints polynomial `z(x)`
    pub z_1: CS::Commitment,

    // Round 3.
    /// Commitment to the low part of the quotient polynomial t(X)
    pub t_lo_1: CS::Commitment,
    /// Commitment to the middle part of the quotient polynomial t(X)
    pub t_mid_1: CS::Commitment,
    /// Commitment to the high part of the quotient polynomial t(X)
    pub t_hi_1: CS::Commitment,

    // Round 4.
    /// Value of `a(ζ)`.
    pub a_zeta: FieldElement&lt;F&gt;,
    /// Value of `b(ζ)`.
    pub b_zeta: FieldElement&lt;F&gt;,
    /// Value of `c(ζ)`.
    pub c_zeta: FieldElement&lt;F&gt;,
    /// Value of `S_σ1(ζ)`.
    pub s1_zeta: FieldElement&lt;F&gt;,
    /// Value of `S_σ2(ζ)`.
    pub s2_zeta: FieldElement&lt;F&gt;,
    /// Value of `z(ζω)`.
    pub z_zeta_omega: FieldElement&lt;F&gt;,

    // Round 5
    /// Value of `p_non_constant(ζ)`.
    pub p_non_constant_zeta: FieldElement&lt;F&gt;,
    ///  Value of `t(ζ)`.
    pub t_zeta: FieldElement&lt;F&gt;,
    /// Batch opening proof for all the evaluations at ζ
    pub w_zeta_1: CS::Commitment,
    /// Single opening proof for `z(ζω)`.
    pub w_zeta_omega_1: CS::Commitment,
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we instantiate a verifier.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verifier = Verifier::new(kzg);
<span class="boring">}
</span></code></pre></pre>
<p>It's an instance of <code>Verifier</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Verifier&lt;F: IsField, CS: IsCommitmentScheme&lt;F&gt;&gt; {
    commitment_scheme: CS,
    phantom: PhantomData&lt;F&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we call the verifier's method <code>verify</code> that outputs a <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(verifier.verify(
    &amp;proof,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key
));
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-gnarks-frontend"><a class="header" href="#using-gnarks-frontend">Using gnark's frontend</a></h2>
<h3 id="exporting-precomputed-values-from-gnarks-frontend"><a class="header" href="#exporting-precomputed-values-from-gnarks-frontend">Exporting precomputed values from gnark's frontend</a></h3>
<p>Here is a function written in <code>go</code> to use gnark's frontend and export a JSON file with all the precomputed values needed by our backend.</p>
<pre><code class="language-go">type SerializedCircuit struct {
	N           int
	N_Padded    uint64
	Omega       string
	Input       []string
	Ql          []string
	Qr          []string
	Qm          []string
	Qo          []string
	Qc          []string
	A           []string
	B           []string
	C           []string
	Permutation []int64
}

func ToJSON(_r1cs *cs.SparseR1CS, pk *plonk_bls12381.ProvingKey, fullWitness fr_bls12381.Vector, witnessPublic fr_bls12381.Vector) {
	// n
	nbConstraints := len(_r1cs.Constraints)
	nbPublic := len(_r1cs.Public)
	n := nbConstraints + nbPublic
	omega := pk.Domain[0].Generator.Text(16)

	// Ql, Qm, Qr, Qo, Qk, S1, S2, S3
	var Ql, Qr, Qm, Qo, Qc []string

	for i := 0; i &lt; nbPublic; i++ { 
		var minus_one fr_bls12381.Element
		minus_one = fr_bls12381.NewElement(1)
		minus_one.Neg(&amp;minus_one)
		zero := fr_bls12381.NewElement(0)
		Ql = append(Ql, minus_one.Text(16))
		Qr = append(Qr, zero.Text(16))
		Qm = append(Qm, zero.Text(16))
		Qo = append(Qo, zero.Text(16))
		Qc = append(Qc, zero.Text(16))
	}

	for i := 0; i &lt; nbConstraints; i++ { // constraints
		Ql = append(Ql, _r1cs.Coefficients[_r1cs.Constraints[i].L.CoeffID()].Text(16))
		Qr = append(Qr, _r1cs.Coefficients[_r1cs.Constraints[i].R.CoeffID()].Text(16))

		var new_Qm fr_bls12381.Element
		new_Qm.Set(&amp;_r1cs.Coefficients[_r1cs.Constraints[i].M[0].CoeffID()]).Mul(&amp;new_Qm, &amp;_r1cs.Coefficients[_r1cs.Constraints[i].M[1].CoeffID()])

		Qm = append(Qm, new_Qm.Text(16))
		Qo = append(Qo, _r1cs.Coefficients[_r1cs.Constraints[i].O.CoeffID()].Text(16))
		Qc = append(Qc, _r1cs.Coefficients[_r1cs.Constraints[i].K].Text(16))
	}

	// Witness
	opt, _ := backend.NewProverConfig()
	var abc, _ = _r1cs.Solve(fullWitness, opt)
	var a, b, c []string
	for i := 0; i &lt; len(_r1cs.Public); i++ {
		a = append(a, witnessPublic[i].Text(16))
		b = append(b, witnessPublic[0].Text(16))
		c = append(c, witnessPublic[0].Text(16))
	}
	for i := 0; i &lt; nbConstraints; i++ { // constraints
		a = append(a, abc[_r1cs.Constraints[i].L.WireID()].Text(16))
		b = append(b, abc[_r1cs.Constraints[i].R.WireID()].Text(16))
		c = append(c, abc[_r1cs.Constraints[i].O.WireID()].Text(16))
	}

	var input []string
	for i := 0; i &lt; len(_r1cs.Public); i++ {
		input = append(input, witnessPublic[i].Text(16))
	}

	data := SerializedCircuit{
		N:           n,
		Omega:       omega,
		N_Padded:    pk.Domain[0].Cardinality,
		Input:       input,
		Ql:          Ql,
		Qr:          Qr,
		Qm:          Qm,
		Qo:          Qo,
		Qc:          Qc,
		A:           a,
		B:           b,
		C:           c,
		Permutation: pk.Permutation,
	}
	file, _ := json.MarshalIndent(data, &quot;&quot;, &quot; &quot;)
	_ = ioutil.WriteFile(&quot;frontend_precomputed_values.json&quot;, file, 0644)
}
</code></pre>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>This is a simple example of how to use it using gnark's backend</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;

	&quot;encoding/json&quot;
	&quot;io/ioutil&quot;

	fr_bls12381 &quot;github.com/consensys/gnark-crypto/ecc/bls12-381/fr&quot;
	&quot;github.com/consensys/gnark/backend&quot;
	plonk_bls12381 &quot;github.com/consensys/gnark/internal/backend/bls12-381/plonk&quot;

	&quot;github.com/consensys/gnark-crypto/ecc&quot;
	&quot;github.com/consensys/gnark/backend/plonk&quot;
	cs &quot;github.com/consensys/gnark/constraint/bls12-381&quot;
	&quot;github.com/consensys/gnark/frontend/cs/scs&quot;
	&quot;github.com/consensys/gnark/test&quot;

	&quot;github.com/consensys/gnark/frontend&quot;
)

// Circuit y == x**e
// only the bitSize least significant bits of e are used
type Circuit struct {
	// tagging a variable is optional
	// default uses variable name and secret visibility.
	X frontend.Variable `gnark:&quot;,public&quot;`
	Y frontend.Variable `gnark:&quot;,public&quot;`

	E frontend.Variable
}

// Define the circuit's constraints
func (circuit *Circuit) Define(api frontend.API) error {
	output := api.Mul(circuit.E, circuit.X)
	five := frontend.Variable(5)
	output2 := api.Add(output, five)
	api.AssertIsEqual(circuit.Y, output2)
	return nil
}

func main() {

	var circuit Circuit

	ccs, err := frontend.Compile(ecc.BLS12_381.ScalarField(), scs.NewBuilder, &amp;circuit)
	if err != nil {
		fmt.Println(&quot;circuit compilation error&quot;)
	}

	_r1cs := ccs.(*cs.SparseR1CS)
	srs, err := test.NewKZGSRS(_r1cs)
	if err != nil {
		panic(err)
	}

	{
		var w Circuit
		w.X = 2
		w.E = 2
		w.Y = 9

		witnessFull, err := frontend.NewWitness(&amp;w, ecc.BLS12_381.ScalarField())
		if err != nil {
			log.Fatal(err)
		}

		witnessPublic, err := frontend.NewWitness(&amp;w, ecc.BLS12_381.ScalarField(), frontend.PublicOnly())
		if err != nil {
			log.Fatal(err)
		}

		pk, vk, err := plonk.Setup(ccs, srs)
		if err != nil {
			log.Fatal(err)
		}

		proof, err := plonk.Prove(ccs, pk, witnessFull)
		if err != nil {
			log.Fatal(err)
		}

		err = plonk.Verify(proof, vk, witnessPublic)
		if err != nil {
			log.Fatal(err)
		}

		fullWitness, _ := witnessFull.Vector().(fr_bls12381.Vector)
		publicWitness, _ := witnessPublic.Vector().(fr_bls12381.Vector)
		ToJSON(_r1cs, pk.(*plonk_bls12381.ProvingKey), fullWitness, publicWitness)
	}
}
</code></pre>
<h2 id="importing-precomputed-values-from-json"><a class="header" href="#importing-precomputed-values-from-json">Importing precomputed values from JSON</a></h2>
<p>To use the precomputed values exported from gnark's frontend there is a function <code>common_preprocessed_input_from_json</code> in the <code>test_utils</code> module that parses it and returns an instance of <code>Witness</code>, an instance of <code>CommonPreprocessedInput</code> and the public input array.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let json_string = fs::read_to_string(frontend_precomputed_values_json_filepath).unwrap();
let (witness, common_preprocessed_input, public_input) = common_preprocessed_input_from_json(&amp;json_string);
let srs = test_srs(common_preprocessed_input.n);
let kzg = KZG::new(srs);
let verifying_key = setup(&amp;common_preprocessed_input, &amp;kzg);
let random_generator = TestRandomFieldGenerator {};
let prover = Prover::new(kzg.clone(), random_generator);
let proof = prover.prove(
    &amp;witness,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key,
);
let verifier = Verifier::new(kzg);
assert!(verifier.verify(
    &amp;proof,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key
));
<span class="boring">}
</span></code></pre></pre>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>If you need to inspect the JSON files exported by <code>ToJSON</code>, the following details may be important to you.</p>
<p>All the matrices <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> are padded with dummy rows so that their length is a power of two. To be able to interpolate their columns, we need a primitive root of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> of that order. Given the particular field used in our implementation, that means that the maximum possible size for a circuit is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>The entries of the dummy rows are filled in with zeroes in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> matrices. The <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrix needs to be consistent with the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrix. Therefore it is filled with the value of the variable with index <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. That is the first public input.</p>
<p>Some other rows in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrix have also dummy values. These are the rows corresponding to the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> columns of the public input rows. In the recap we denoted them with the empty <code>-</code> symbol. They are filled in with the same logic as the padding rows, as well as the corresponding values in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrix.</p>
<h1 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h1>
<p>The implementation pretty much follows the rounds as are described in the <a href="./protocol.html">protocol</a> section. There are a few details that are worth mentioning.</p>
<h2 id="commitment-scheme"><a class="header" href="#commitment-scheme">Commitment Scheme</a></h2>
<p>The commitment scheme we use is the <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">Kate-Zaverucha-Goldberg</a> scheme with the <code>BLS 12 381</code> curve and the ate pairing. It can be found in the <code>commitments</code> module of the <code>lambdaworks_crypto</code> package.</p>
<p>The order <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> of the cyclic subgroup is</p>
<pre><code>0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
</code></pre>
<p>The maximum power of two that divides <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>. Therefore, that is the maximum possible order for a primitive root of unity in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> with order a power of two. </p>
<h2 id="fiat-shamir"><a class="header" href="#fiat-shamir">Fiat-Shamir</a></h2>
<h3 id="transcript-strategy"><a class="header" href="#transcript-strategy">Transcript strategy</a></h3>
<p>Here we describe our implementation of the transcript used for the Fiat-Shamir heuristic.</p>
<p>A <code>Transcript</code> exposes two methods: <code>append</code> and <code>challenge</code>.</p>
<p>The method <code>append</code> adds a message to the transcript by updating the internal state of the hasher with the raw bytes of the message. </p>
<p>The  method <code>challenge</code> returns the result of the hasher using the current internal state of the hasher. It subsequently resets the hasher and updates the internal state with the last result.</p>
<p>Here is an example of this process:</p>
<ol>
<li>Start a fresh transcript. </li>
<li>Call <code>append</code> and pass <code>message_1</code>.</li>
<li>Call <code>append</code> and pass <code>message_2</code>.</li>
<li>The internal state of the hasher at this point is <code>message_2 || message_1</code>.</li>
<li>Call <code>challenge</code>. The output is <code>Hash(message_2 || message_1)</code>.</li>
<li>Call <code>append</code> and pass <code>message_3</code>.</li>
<li>Call <code>challenge</code>. The output is <code>Hash(message_3 || Hash(message_2 || message_1))</code>.</li>
<li>Call <code>append</code> and pass <code>message_4</code>.</li>
</ol>
<p>The internal state of the hasher at the end of this exercise is <code>message_4 || Hash(message_3 || Hash(message_2 || message_1))</code></p>
<p>The underlying hasher function we use is <code>h=sha3</code>.</p>
<h3 id="field-elements"><a class="header" href="#field-elements">Field elements</a></h3>
<p>The result of every challenge is a <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>-bit string, which is interpreted as an integer in big-endian order. A field element is constructed out of it by taking modulo the field order. The prime field used in this implementation has a <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">255</span></span></span></span>-bit order. Therefore some field elements are more probable to occur than others because they have more representatives as 256-bit integers.</p>
<h3 id="strong-fiat-shamir"><a class="header" href="#strong-fiat-shamir">Strong Fiat-Shamir</a></h3>
<p>The first messages added to the transcript are all commitments of the polynomials of the common preprocessed input and the values of the public inputs. This prevents a known vulnerability called &quot;weak Fiat-Shamir&quot;.
Check out the following resources to learn more about it.</p>
<ul>
<li><a href="https://www.zkdocs.com/docs/zkdocs/protocol-primitives/fiat-shamir/#what-can-go-wrong">What can go wrong (zkdocs)</a></li>
<li><a href="https://eprint.iacr.org/2016/771.pdf">How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../proving_systems/plonk/protocol.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../fft/benchmarks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../proving_systems/plonk/protocol.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../fft/benchmarks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
